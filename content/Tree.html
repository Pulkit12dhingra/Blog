<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Byte-Sized-Brilliance-AI</title>
  <link rel="icon" type="image/png" href="../img/icon.png" />

  <!-- Meta for sharing -->
  <meta property="og:title" content="Pulkit's Blog" />
  <meta property="og:description" content="Learn how to implement a Binary Search Tree (BST) from scratch in Python with insertion, traversal, search, and deletion." />
  <meta property="og:image" content="../img/social-preview.jpg" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Pulkit's Blog" />
  <meta name="twitter:description" content="Learn how to implement a Binary Search Tree (BST) from scratch in Python with insertion, traversal, search, and deletion." />
  <meta name="twitter:image" content="../img/social-preview.jpg" />

  <!-- CSS and Icons -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet" />
  <link rel="stylesheet" href="data/style.css?v=1.0.0" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet"/>
</head>

<body>
<div class="container mt-4">
  <div class="d-flex flex-column flex-md-row justify-content-between align-items-start align-items-md-center mb-4">
    <h2 class="fw-bold mb-3">Binary Search Trees in Python — From Scratch 🌲</h2>
    <a href="../index.html" class="btn btn-primary">← Back to Home</a>
  </div>
  <p class="text-muted">Published: <span id="publish-date">June 26, 2025</span></p>
  <hr />

  <p>In this post, we’ll implement a Binary Search Tree (BST) from the ground up using Python. You'll learn how to:</p>
  <ul>
    <li>Create a tree node</li>
    <li>Insert elements</li>
    <li>Traverse the tree (in-order)</li>
    <li>Search for a value</li>
    <li>Delete nodes while preserving BST rules</li>
    <li>Display the tree in a readable format</li>
  </ul>

  <h4 class="mt-4">🌱 Step 1: Define the Tree Node</h4>
  <pre class="bg-light p-3 rounded"><code>class treeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None</code></pre>

  <h4 class="mt-4">📥 Step 2: Insert Values into the Tree</h4>
  <pre class="bg-light p-3 rounded"><code>def insert(root, value):
    if root is None:
        return treeNode(value)
    if value < root.value:
        root.left = insert(root.left, value)
    else:
        root.right = insert(root.right, value)
    return root</code></pre>

  <h4 class="mt-4">📋 Step 3: In-order Traversal (Sorted Output)</h4>
  <pre class="bg-light p-3 rounded"><code>def inorder_traversal(root):
    if root is None:
        return []
    return inorder_traversal(root.left) + [root.value] + inorder_traversal(root.right)</code></pre>

  <h4 class="mt-4">🔍 Step 4: Search for a Value</h4>
  <pre class="bg-light p-3 rounded"><code>def search(root, value):
    if root is None or root.value == value:
        return root
    if value < root.value:
        return search(root.left, value)
    return search(root.right, value)</code></pre>

  <h4 class="mt-4">❌ Step 5: Delete a Node</h4>
  <p>This handles three scenarios: leaf deletion, single child, and two children (by replacing with the smallest right subtree node).</p>
  <pre class="bg-light p-3 rounded"><code>def delete_node(root, value):
    if root is None:
        return root
    if value < root.value:
        root.left = delete_node(root.left, value)
    elif value > root.value:
        root.right = delete_node(root.right, value)
    else:
        if root.left is None:
            return root.right
        elif root.right is None:
            return root.left
        min_larger_node = root.right
        while min_larger_node.left is not None:
            min_larger_node = min_larger_node.left
        root.value = min_larger_node.value
        root.right = delete_node(root.right, min_larger_node.value)
    return root</code></pre>

  <h4 class="mt-4">🌲 Step 6: Display the Tree (Rotated 90°)</h4>
  <pre class="bg-light p-3 rounded"><code>def display_tree(root, level=0):
    if root is not None:
        display_tree(root.right, level + 1)
        print(' ' * 4 * level + '->', root.value)
        display_tree(root.left, level + 1)</code></pre>

  <h4 class="mt-4">🚀 Final Demo</h4>
  <pre class="bg-light p-3 rounded"><code>if __name__ == "__main__":
    root = None
    values = [5, 3, 7, 2, 4, 6, 8]
    for value in values:
        root = insert(root, value)

    print("Inorder Traversal:", inorder_traversal(root))

    search_value = 4
    found_node = search(root, search_value)
    print(f"Node with value {search_value} {'found' if found_node else 'not found'}.")

    print("\nTree structure:")
    display_tree(root)

    root = delete_node(root, 3)
    print("\nTree after deleting 3:")
    display_tree(root)</code></pre>

  <h4 class="mt-4">✅ Final Thoughts</h4>
  <p>Binary Search Trees are foundational data structures in computer science. Writing one from scratch teaches recursion, tree logic, and algorithmic thinking. Whether you're preparing for interviews or exploring algorithms, mastering BSTs is always worth your time.</p>

  <h4 class="mt-4">🔗 Reference</h4>
  <p><a href="https://github.com/Pulkit12dhingra/Blog/blob/main/notebooks/tree.ipynb" target="_blank">📓 tree.ipynb on GitHub</a></p>
</div>
</body>
</html>
