<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Learn how to implement a Binary Search Tree (BST) from scratch in Python, covering insertion, search, deletion, traversal, and visualization." />
  <title>Binary Search Trees in Python: From Scratch | Byte-Sized-Brilliance-AI</title>
  <link rel="icon" type="image/png" href="../img/icon.png" />

  <!-- Preconnect to external domains -->
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="preconnect" href="https://www.googletagmanager.com" crossorigin>

  <!-- Open Graph -->
  <meta property="og:title" content="Binary Search Trees in Python: From Scratch" />
  <meta property="og:description" content="Learn how to implement a Binary Search Tree (BST) from scratch in Python, covering insertion, search, deletion, traversal, and visualization." />
  <meta property="og:image" content="../img/social-preview.jpg" />
  <meta property="og:type" content="article" />

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Binary Search Trees in Python: From Scratch" />
  <meta name="twitter:description" content="Learn how to implement a Binary Search Tree (BST) from scratch in Python, covering insertion, search, deletion, traversal, and visualization." />
  <meta name="twitter:image" content="../img/social-preview.jpg" />

  <!-- Critical CSS loaded first -->
  <link rel="stylesheet" href="../data/style.css?v=1.0.0" />

  <!-- Non-critical CSS loaded asynchronously -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    rel="stylesheet"
    media="print"
    onload="this.media='all'"
  />
  <noscript>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  </noscript>

  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css"
    rel="stylesheet"
    media="print"
    onload="this.media='all'"
  />
  <noscript>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet" />
  </noscript>

  <link
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
    rel="stylesheet"
    media="print"
    onload="this.media='all'"
  />
  <noscript>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet" />
  </noscript>

  <!-- Deferred Google Analytics -->
  <script>
    window.addEventListener('load', function() {
      setTimeout(function() {
        var script = document.createElement('script');
        script.src = 'https://www.googletagmanager.com/gtag/js?id=G-8JMS98M7C7';
        script.async = true;
        script.onload = function() {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-8JMS98M7C7');
        };
        document.head.appendChild(script);
      }, 1500);
    });
  </script>
</head>

<body>
<div class="container mt-4">
  <div class="d-flex flex-column flex-md-row justify-content-between align-items-start align-items-md-center mb-4">
    <h2 class="fw-bold mb-3">Binary Search Trees in Python — From Scratch </h2>
    <a href="../index.html" class="btn btn-primary">← Back to Home</a>
  </div>
  <hr />

  <p>In this post, we'll implement a Binary Search Tree (BST) from the ground up using Python. You'll learn how to:</p>
  <ul>
    <li>Create a tree node</li>
    <li>Insert elements</li>
    <li>Traverse the tree (in-order)</li>
    <li>Search for a value</li>
    <li>Delete nodes while preserving BST rules</li>
    <li>Display the tree in a readable format</li>
  </ul>

  <h4 class="mt-4">Prerequisites</h4>
  <p>
    This tutorial assumes basic knowledge of Python and recursion. No external libraries are required—everything is built using pure Python.
  </p>
  <p>
    <strong>What you'll learn:</strong>
  </p>
  <ul>
    <li>Understanding Binary Search Tree properties and invariants</li>
    <li>Recursive algorithms for tree operations</li>
    <li>Different node deletion strategies</li>
    <li>Tree traversal techniques</li>
    <li>Visual representation of tree structures</li>
  </ul>

  <h4 class="mt-4">Understanding Binary Search Trees</h4>
  <p>
    A Binary Search Tree is a hierarchical data structure where each node has at most two children. The key property is:
  </p>
  <ul>
    <li><strong>Left subtree</strong> contains only nodes with values less than the parent node</li>
    <li><strong>Right subtree</strong> contains only nodes with values greater than or equal to the parent node</li>
  </ul>
  <p>
    This property enables efficient searching, insertion, and deletion operations with average time complexity of O(log n) for balanced trees.
  </p>

  <h4 class="mt-4">Step 1: Define the Tree Node</h4>
  <pre class="bg-light p-3 rounded"><code>class treeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None</code></pre>
  <p>
    Each node stores three pieces of information: the <code>value</code> (data), a reference to the <code>left</code> child, and a reference to the <code>right</code> child. Initially, both children are <code>None</code>, making the node a leaf.
  </p>

  <h4 class="mt-4">Step 2: Insert Values into the Tree</h4>
  <pre class="bg-light p-3 rounded"><code>def insert(root, value):
    if root is None:
        return treeNode(value)
    if value < root.value:
        root.left = insert(root.left, value)
    else:
        root.right = insert(root.right, value)
    return root</code></pre>
  <p>
    The insertion algorithm follows the BST property: if the new value is less than the current node, go left; otherwise, go right. This recursive approach continues until we find an empty spot (<code>None</code>) where we create a new node.
  </p>

  <h4 class="mt-4">Step 3: In-order Traversal (Sorted Output)</h4>
  <pre class="bg-light p-3 rounded"><code>def inorder_traversal(root):
    if root is None:
        return []
    return inorder_traversal(root.left) + [root.value] + inorder_traversal(root.right)</code></pre>
  <p>
    In-order traversal visits nodes in the following sequence: left subtree → current node → right subtree. For a BST, this produces a sorted list of values. This is one of three common traversal methods (the others being pre-order and post-order).
  </p>

  <h4 class="mt-4">Step 4: Search for a Value</h4>
  <pre class="bg-light p-3 rounded"><code>def search(root, value):
    if root is None or root.value == value:
        return root
    if value < root.value:
        return search(root.left, value)
    return search(root.right, value)</code></pre>
  <p>
    Searching leverages the BST property for efficiency. At each node, we compare the target value with the current node's value. If the target is smaller, we search the left subtree; if larger, we search the right subtree. This eliminates half of the remaining nodes at each step.
  </p>

  <h4 class="mt-4">Step 5: Delete a Node</h4>
  <p>Deletion is the most complex operation in a BST. It handles three scenarios:</p>
  <ul>
    <li><strong>Leaf node (no children):</strong> Simply remove the node</li>
    <li><strong>One child:</strong> Replace the node with its child</li>
    <li><strong>Two children:</strong> Replace the node's value with the smallest value from the right subtree (in-order successor), then delete that successor node</li>
  </ul>
  <pre class="bg-light p-3 rounded"><code>def delete_node(root, value):
    if root is None:
        return root
    if value < root.value:
        root.left = delete_node(root.left, value)
    elif value > root.value:
        root.right = delete_node(root.right, value)
    else:
        if root.left is None:
            return root.right
        elif root.right is None:
            return root.left
        min_larger_node = root.right
        while min_larger_node.left is not None:
            min_larger_node = min_larger_node.left
        root.value = min_larger_node.value
        root.right = delete_node(root.right, min_larger_node.value)
    return root</code></pre>

  <h4 class="mt-4">Step 6: Display the Tree (Rotated 90°)</h4>
  <pre class="bg-light p-3 rounded"><code>def display_tree(root, level=0):
    if root is not None:
        display_tree(root.right, level + 1)
        print(' ' * 4 * level + '->', root.value)
        display_tree(root.left, level + 1)</code></pre>
  <p>
    This visualization function displays the tree rotated 90 degrees counter-clockwise. The rightmost values appear at the top, and the leftmost values at the bottom. The indentation shows the tree's depth, making it easy to understand the structure visually.
  </p>

  <h4 class="mt-4">Final Demo</h4>
  <pre class="bg-light p-3 rounded"><code>if __name__ == "__main__":
    root = None
    values = [5, 3, 7, 2, 4, 6, 8]
    for value in values:
        root = insert(root, value)

    print("Inorder Traversal:", inorder_traversal(root))

    search_value = 4
    found_node = search(root, search_value)
    print(f"Node with value {search_value} {'found' if found_node else 'not found'}.")

    print("\nTree structure:")
    display_tree(root)

    root = delete_node(root, 3)
    print("\nTree after deleting 3:")
    display_tree(root)</code></pre>

  <h4 class="mt-4">Time Complexity Analysis</h4>
  <p>
    Understanding the performance characteristics of BST operations is crucial:
  </p>
  <ul>
    <li><strong>Search:</strong> O(h) where h is the height of the tree. Best case O(log n) for balanced trees, worst case O(n) for skewed trees.</li>
    <li><strong>Insertion:</strong> O(h) - same as search, since we traverse from root to leaf.</li>
    <li><strong>Deletion:</strong> O(h) - requires searching plus potential subtree operations.</li>
    <li><strong>In-order Traversal:</strong> O(n) - must visit every node once.</li>
  </ul>
  <p>
    <strong>Note:</strong> For worst-case scenarios where the tree becomes a linked list (inserting sorted data), consider using self-balancing trees like AVL or Red-Black trees.
  </p>

  <h4 class="mt-4">Common Pitfalls & Best Practices</h4>
  <ul>
    <li><strong>Unbalanced Trees:</strong> Inserting sorted data creates a skewed tree. Consider randomizing insertion order or using balanced tree variants.</li>
    <li><strong>Duplicate Values:</strong> Our implementation inserts duplicates to the right. Decide whether to allow duplicates based on your use case.</li>
    <li><strong>Empty Tree Handling:</strong> Always check if the root is <code>None</code> before operations.</li>
    <li><strong>Memory Management:</strong> In production code, consider garbage collection implications when deleting nodes.</li>
  </ul>

  <h4 class="mt-4">Extending Your BST Implementation</h4>
  <p>
    Once you've mastered the basics, try implementing these advanced features:
  </p>
  <ul>
    <li><strong>Additional Traversals:</strong> Pre-order and post-order traversal methods</li>
    <li><strong>Tree Properties:</strong> Methods to calculate height, count nodes, or check if the tree is balanced</li>
    <li><strong>Range Queries:</strong> Find all values within a given range</li>
    <li><strong>Level-order Traversal:</strong> Traverse the tree level by level using a queue</li>
    <li><strong>Parent Pointers:</strong> Add parent references for easier upward traversal</li>
    <li><strong>Iterative Implementations:</strong> Convert recursive methods to iterative ones using stacks</li>
  </ul>

  <h4 class="mt-4">Real-World Applications</h4>
  <p>
    Binary Search Trees are fundamental to many practical applications:
  </p>
  <ul>
    <li><strong>Database Indexing:</strong> B-trees (BST variants) power database indices</li>
    <li><strong>File Systems:</strong> Directory structures often use tree-based organization</li>
    <li><strong>Expression Parsing:</strong> Syntax trees for compilers and calculators</li>
    <li><strong>Auto-complete:</strong> Trie structures (specialized trees) for predictive text</li>
    <li><strong>Game AI:</strong> Decision trees for game logic and AI behavior</li>
  </ul>

  <h4 class="mt-4">Final Thoughts</h4>
  <p>Binary Search Trees are foundational data structures in computer science. Writing one from scratch teaches recursion, tree logic, and algorithmic thinking. Whether you're preparing for interviews or exploring algorithms, mastering BSTs is always worth your time.</p>
  <p>
    The implementation we've built here demonstrates the core concepts, but remember that production systems often use self-balancing variants (AVL, Red-Black trees) to guarantee O(log n) performance. Understanding the basic BST is the essential first step toward working with these more advanced structures.
  </p>

  <h4 class="mt-4">Reference</h4>
  <p>For the complete implementation with additional examples and test cases, check out the Jupyter notebook:</p>
  <p><a href="https://github.com/Pulkit12dhingra/Algorithms/blob/main/tree.ipynb" target="_blank">tree.ipynb on GitHub</a></p>
</div>

<!-- Footer -->
<footer class="bg-light py-4 mt-5 border-top">
  <div class="container text-center">
    <p class="text-muted mb-1">
      <i class="bi bi-person-circle me-2"></i>
      <strong>Written by:</strong> <a href="https://www.linkedin.com/in/pulkit-dhingra-4b7312193/" target="_blank" rel="noopener noreferrer" class="text-decoration-none">Pulkit Dhingra</a>
    </p>
    <p class="text-muted small mb-0">
      © 2025 Byte-Sized-Brilliance-AI. All rights reserved.
    </p>
  </div>
</footer>

</body>
</html>
