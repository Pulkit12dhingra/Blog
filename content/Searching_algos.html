<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Learn the fundamentals of Linear and Binary Search algorithms, their implementation in Python, and when to use each. Includes step-by-step code and comparison." />
  <title>Exploring Search Algorithms: From Linear to Binary | Byte-Sized-Brilliance-AI</title>
  <link rel="icon" type="image/png" href="../img/icon.png" />

  <!-- Preconnect to external domains -->
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="preconnect" href="https://www.googletagmanager.com" crossorigin>

  <!-- Open Graph -->
  <meta property="og:title" content="Exploring Search Algorithms: From Linear to Binary" />
  <meta property="og:description" content="Learn the fundamentals of Linear and Binary Search algorithms, their implementation in Python, and when to use each. Includes step-by-step code and comparison." />
  <meta property="og:image" content="../img/social-preview.jpg" />
  <meta property="og:type" content="article" />

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Exploring Search Algorithms: From Linear to Binary" />
  <meta name="twitter:description" content="Learn the fundamentals of Linear and Binary Search algorithms, their implementation in Python, and when to use each. Includes step-by-step code and comparison." />
  <meta name="twitter:image" content="../img/social-preview.jpg" />

  <!-- Critical CSS loaded first -->
  <link rel="stylesheet" href="../data/style.css?v=1.0.0" />

  <!-- Non-critical CSS loaded asynchronously -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    rel="stylesheet"
    media="print"
    onload="this.media='all'"
  />
  <noscript>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  </noscript>

  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css"
    rel="stylesheet"
    media="print"
    onload="this.media='all'"
  />
  <noscript>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet" />
  </noscript>

  <link
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
    rel="stylesheet"
    media="print"
    onload="this.media='all'"
  />
  <noscript>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet" />
  </noscript>

  <!-- Deferred Google Analytics -->
  <script>
    window.addEventListener('load', function() {
      setTimeout(function() {
        var script = document.createElement('script');
        script.src = 'https://www.googletagmanager.com/gtag/js?id=G-8JMS98M7C7';
        script.async = true;
        script.onload = function() {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-8JMS98M7C7');
        };
        document.head.appendChild(script);
      }, 1500);
    });
  </script>
</head>
<body>
<div class="container mt-4">
  <div class="d-flex flex-column flex-md-row justify-content-between align-items-start align-items-md-center mb-4">
    <h2 class="fw-bold mb-3">Exploring Search Algorithms — From Linear to Binary </h2>
    <a href="../index.html" class="btn btn-primary">← Back to Home</a>
  </div>

  <hr />

  <p>
    Whether you're just getting started with data structures or brushing up for coding interviews, understanding search algorithms is fundamental.
    In this blog, we break down two essential techniques: <strong>Linear Search</strong> and <strong>Binary Search</strong>. We'll walk through their logic, time complexity, and implement them step-by-step in Python.
  </p>

  <h4 class="mt-4">Prerequisites</h4>
  <p>
    This tutorial requires only basic Python knowledge. No external libraries are needed.
  </p>
  <p>
    <strong>What you'll learn:</strong>
  </p>
  <ul>
    <li>How Linear Search and Binary Search algorithms work</li>
    <li>Time and space complexity analysis</li>
    <li>When to use each search algorithm</li>
    <li>Implementation techniques and best practices</li>
    <li>Common variations and optimizations</li>
  </ul>

  <h4 class="mt-4">Understanding Search Algorithms</h4>
  <p>
    Searching is one of the most common operations in computer science. Whether you're looking up a contact in your phone or finding a specific record in a database, search algorithms power these operations. The efficiency of your search algorithm can dramatically impact application performance.
  </p>

  <h4 class="mt-4">Linear Search — The Brute Force Hero</h4>
  <p>
    Linear search is the simplest way to find an element in a list: go through each element one by one until you find the target — or exhaust the list.
  </p>
  <pre class="bg-light p-3 rounded"><code>def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1</code></pre>
  <p><strong>Time Complexity:</strong> O(n)</p>
  <p><strong>Best Case:</strong> Element at the beginning</p>
  <p><strong>Worst Case:</strong> Element at the end or not found</p>
  <p><strong>Space Complexity:</strong> O(1) - only uses a constant amount of extra space</p>
  <p>
    <strong>Advantages:</strong> Works on unsorted data, simple to implement, no preprocessing required<br>
    <strong>Disadvantages:</strong> Slow for large datasets, inefficient for repeated searches
  </p>

  <h4 class="mt-4">Binary Search — Divide and Conquer</h4>
  <p>
    Binary search is a much faster method — but only works on sorted arrays. It repeatedly divides the search interval in half.
  </p>
  <pre class="bg-light p-3 rounded"><code>def binary_search(arr, target):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1</code></pre>
  <p><strong>Time Complexity:</strong> O(log n)</p>
  <p><strong>Best Case:</strong> Middle element</p>
  <p><strong>Worst Case:</strong> Element not in the list</p>
  <p><strong>Space Complexity:</strong> O(1) for iterative, O(log n) for recursive (call stack)</p>
  <p>
    <strong>Advantages:</strong> Extremely fast for large sorted datasets, efficient for repeated searches<br>
    <strong>Disadvantages:</strong> Requires sorted data, slightly more complex to implement
  </p>

  <h4 class="mt-4">Recursive Binary Search</h4>
  <p>
    Binary search can also be implemented recursively, which some find more intuitive:
  </p>
  <pre class="bg-light p-3 rounded"><code>def binary_search_recursive(arr, target, low, high):
    if low > high:
        return -1
    
    mid = (low + high) // 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, high)
    else:
        return binary_search_recursive(arr, target, low, mid - 1)</code></pre>
  <p>
    The recursive version is more elegant but uses additional stack space. For very large arrays, the iterative approach is preferred to avoid stack overflow.
  </p>

  <h4 class="mt-4">Let's Test Them!</h4>
  <p>We’ll use a sample array and search for a number using both methods.</p>
  <pre class="bg-light p-3 rounded"><code>arr = [2, 4, 6, 8, 10, 12, 14, 16]
target = 10

print("Linear Search:", linear_search(arr, target))
print("Binary Search:", binary_search(arr, target))</code></pre>

  <h4 class="mt-4">When Should You Use Which?</h4>
  <div class="table-responsive">
    <table class="table table-bordered table-striped">
      <thead class="table-dark">
        <tr>
          <th>Criteria</th>
          <th>Linear Search</th>
          <th>Binary Search</th>
        </tr>
      </thead>
      <tbody>
        <tr><td>Data Requirement</td><td>Unsorted</td><td>Sorted only</td></tr>
        <tr><td>Time Complexity</td><td>O(n)</td><td>O(log n)</td></tr>
        <tr><td>Implementation</td><td>Very simple</td><td>Requires more logic</td></tr>
        <tr><td>Use Case</td><td>Small or unsorted data</td><td>Large, sorted data</td></tr>
      </tbody>
    </table>
  </div>

  <h4 class="mt-4">Performance Comparison</h4>
  <p>
    To illustrate the difference, consider searching in an array of 1,000,000 elements:
  </p>
  <ul>
    <li><strong>Linear Search:</strong> Might examine up to 1,000,000 elements (worst case)</li>
    <li><strong>Binary Search:</strong> Examines at most log₂(1,000,000) ≈ 20 elements</li>
  </ul>
  <p>
    This massive difference (50,000x faster!) explains why databases use binary search-like structures (B-trees) for indexing.
  </p>

  <h4 class="mt-4">Common Variations and Extensions</h4>
  <ul>
    <li><strong>Finding First/Last Occurrence:</strong> Modify binary search to continue after finding the target</li>
    <li><strong>Finding Insertion Point:</strong> Determine where to insert an element to maintain sorted order</li>
    <li><strong>Searching in Rotated Arrays:</strong> Modified binary search for arrays rotated at an unknown pivot</li>
    <li><strong>Interpolation Search:</strong> Improves on binary search for uniformly distributed data</li>
    <li><strong>Exponential Search:</strong> Useful for unbounded/infinite lists</li>
  </ul>

  <h4 class="mt-4">Real-World Applications</h4>
  <ul>
    <li><strong>Databases:</strong> B-tree indices use variants of binary search for fast lookups</li>
    <li><strong>Version Control:</strong> Git bisect uses binary search to find bug-introducing commits</li>
    <li><strong>Auto-complete:</strong> Sorted dictionaries enable fast prefix matching</li>
    <li><strong>Computer Networks:</strong> Binary search in routing tables</li>
    <li><strong>Machine Learning:</strong> Hyperparameter tuning often uses binary search approaches</li>
  </ul>

  <h4 class="mt-4">Best Practices</h4>
  <ul>
    <li><strong>Avoid Integer Overflow:</strong> Use <code>mid = low + (high - low) // 2</code> instead of <code>(low + high) // 2</code> in languages where overflow is a concern</li>
    <li><strong>Sort Cost:</strong> If you only search once, sorting + binary search (O(n log n) + O(log n)) may be slower than linear search (O(n))</li>
    <li><strong>Cache Locality:</strong> Linear search may be faster for small arrays due to better cache performance</li>
    <li><strong>Built-in Functions:</strong> Python's <code>bisect</code> module provides optimized binary search implementations</li>
  </ul>

  <h4 class="mt-4">Final Thoughts</h4>
  <p>
    Understanding these core algorithms sets a strong foundation for tackling more complex problems. While linear search is versatile, binary search's efficiency shines in sorted data scenarios. Master both — they're classic interview staples!
  </p>
  <p>
    Remember: the best algorithm depends on your specific use case. Consider data size, whether it's sorted, search frequency, and implementation complexity. In production code, leverage built-in libraries like Python's <code>bisect</code> module for battle-tested implementations.
  </p>

  <h4 class="mt-4">Reference</h4>
  <p>For complete implementations with additional examples and test cases:</p>
  <p><a href="https://github.com/Pulkit12dhingra/Algorithms/blob/main/searching_algos.ipynb" target="_blank">searching_algos.ipynb on GitHub</a></p>
</div>

<!-- Footer -->
<footer class="bg-light py-4 mt-5 border-top">
  <div class="container text-center">
    <p class="text-muted mb-1">
      <i class="bi bi-person-circle me-2"></i>
      <strong>Written by:</strong> <a href="https://www.linkedin.com/in/pulkit-dhingra-4b7312193/" target="_blank" rel="noopener noreferrer" class="text-decoration-none">Pulkit Dhingra</a>
    </p>
    <p class="text-muted small mb-0">
      © 2025 Byte-Sized-Brilliance-AI. All rights reserved.
    </p>
  </div>
</footer>

</body>
</html>
